<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Three.js First-Person Scene Template</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

// ---------- Scene, Camera, Renderer ----------
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,                      // fov
  window.innerWidth / window.innerHeight, // aspect
  0.1,                     // near
  1000                     // far
);

// Place camera at player's eye height; position will be updated when camera is attached to player
camera.position.set(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// ---------- Basic Lighting ----------
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
hemi.position.set(0, 50, 0);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(-5, 10, -5);
dir.castShadow = true;
scene.add(dir);

// ---------- Ground and Example Objects ----------
const groundMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

const box = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshStandardMaterial({ color: 0x00aaee })
);
box.position.set(0, 0.5, -5);
scene.add(box);

// ---------- First-Person Player Object ----------
const player = new THREE.Object3D();
player.position.set(0, 0, 0);
scene.add(player);

// Attach camera to player for true first-person view so camera moves/rotates with player
player.add(camera);

// Optional: offset camera to eye height relative to player
camera.position.set(0, 1.6, 0);

// ---------- Simple First-Person Controls (keyboard + mouse look) ----------
let pitch = 0;  // up/down rotation
let yaw = 0;    // left/right rotation
const sensitivity = 0.002;
const moveSpeed = 5.0;
const keys = { forward: false, back: false, left: false, right: false };

function onPointerMove(e) {
  if (document.pointerLockElement === renderer.domElement) {
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    player.rotation.y = yaw;
    camera.rotation.x = pitch;
  }
}

function onKeyDown(e) {
  if (e.code === 'KeyW') keys.forward = true;
  if (e.code === 'KeyS') keys.back = true;
  if (e.code === 'KeyA') keys.left = true;
  if (e.code === 'KeyD') keys.right = true;
}

function onKeyUp(e) {
  if (e.code === 'KeyW') keys.forward = false;
  if (e.code === 'KeyS') keys.back = false;
  if (e.code === 'KeyA') keys.left = false;
  if (e.code === 'KeyD') keys.right = false;
}

renderer.domElement.addEventListener('click', () => {
  renderer.domElement.requestPointerLock();
});

window.addEventListener('pointermove', onPointerMove);
window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);

// ---------- Resize Handling ----------
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ---------- Animation Loop ----------
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // Movement relative to player's orientation
  const forward = (keys.forward ? 1 : 0) - (keys.back ? 1 : 0);
  const strafe = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
  if (forward !== 0 || strafe !== 0) {
    const forwardVec = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
    const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(player.quaternion);
    const move = forwardVec.multiplyScalar(forward * moveSpeed * dt)
               .add(rightVec.multiplyScalar(strafe * moveSpeed * dt));
    player.position.add(move);
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
